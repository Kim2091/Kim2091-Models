name: Update README with Releases

on:
  release:
    types: [published, edited]
  workflow_dispatch:

jobs:
  update-readme:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.repository.default_branch }}
      
      - name: Fetch releases and update README
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Fetch all releases
          releases=$(gh api repos/${{ github.repository }}/releases --paginate)
          
          # Parse releases and store in temporary file with sortable dates
          echo "$releases" | jq -r '.[] | @json' | while read -r release; do
            tag=$(echo "$release" | jq -r '.tag_name')
            html_url=$(echo "$release" | jq -r '.html_url')
            body=$(echo "$release" | jq -r '.body')
            
            # Extract date from body using regex pattern **Date:** [date]
            date=$(echo "$body" | grep -oP '\*\*Date:\*\*\s*\K[^\s\n]+' | head -1)
            
            # If no date found, use published_at as fallback
            if [ -z "$date" ]; then
              date=$(echo "$release" | jq -r '.published_at' | cut -d'T' -f1)
            fi
            
            # Convert date to sortable format YYYYMMDD for sorting
            # Handle multiple formats: M/D/YY, MM/DD/YY, M-D-YY, MM-DD-YY, YYYY-MM-DD
            sort_date=$(echo "$date" | awk -F'[-/]' '{
              if (NF == 3) {
                # Check if it is YYYY-MM-DD format (year is 4 digits and first)
                if (length($1) == 4 && $1 > 1900) {
                  # YYYY-MM-DD or YYYY/MM/DD format
                  year=$1; month=$2; day=$3
                  printf "%04d%02d%02d", year, month, day
                }
                # Check if year is clearly in third position (4 digits or >24)
                else if (length($3) == 4 || $3 > 24) {
                  # M/D/YYYY, MM/DD/YYYY, M-D-YY, MM-DD-YY format
                  year = (length($3) == 2) ? "20"$3 : $3
                  month=$1; day=$2
                  printf "%04d%02d%02d", year, month, day
                }
                # If first value >12, assume YY/MM/DD or YY-MM-DD
                else if ($1 > 12) {
                  year = (length($1) == 2) ? "20"$1 : $1
                  month=$2; day=$3
                  printf "%04d%02d%02d", year, month, day
                }
                # Default to M/D/YY or M-D-YY format
                else {
                  year = (length($3) == 2) ? "20"$3 : $3
                  month=$1; day=$2
                  printf "%04d%02d%02d", year, month, day
                }
              } else {
                # Fallback
                print "00000000"
              }
            }')
            
            # Convert to standardized MM/DD/YY format for display
            display_date=$(echo "$date" | awk -F'[-/]' '{
              if (NF == 3) {
                # Check if it is YYYY-MM-DD format (year is 4 digits and first)
                if (length($1) == 4 && $1 > 1900) {
                  year=substr($1, 3, 2); month=$2; day=$3
                  printf "%02d/%02d/%s", month, day, year
                }
                # Check if year is clearly in third position (4 digits or >24)
                else if (length($3) == 4 || $3 > 24) {
                  year = (length($3) == 2) ? $3 : substr($3, 3, 2)
                  month=$1; day=$2
                  printf "%02d/%02d/%s", month, day, year
                }
                # If first value >12, assume YY/MM/DD or YY-MM-DD
                else if ($1 > 12) {
                  year = (length($1) == 2) ? $1 : substr($1, 3, 2)
                  month=$2; day=$3
                  printf "%02d/%02d/%s", month, day, year
                }
                # Default to M/D/YY or M-D-YY format
                else {
                  year = (length($3) == 2) ? $3 : substr($3, 3, 2)
                  month=$1; day=$2
                  printf "%02d/%02d/%s", month, day, year
                }
              } else {
                print $0
              }
            }')
            
            # Store: sortable_date|tag|url|display_date
            echo "$sort_date|$tag|$html_url|$display_date" >> releases_temp.txt
          done
          
          # Sort by date (newest first) and build releases section
          echo "## Releases" > releases_section.md
          echo "" >> releases_section.md
          echo "_All dates are in MM/DD/YY format_" >> releases_section.md
          echo "" >> releases_section.md
          
          # Get the latest release (first line after sorting)
          first_line=true
          sort -r releases_temp.txt | while IFS='|' read -r sort_date tag html_url date; do
            if [ "$first_line" = true ]; then
              echo "### ðŸŽ‰ Latest Release: [$tag]($html_url)" >> releases_section.md
              echo "**Released:** $date" >> releases_section.md
              echo "" >> releases_section.md
              echo "---" >> releases_section.md
              echo "" >> releases_section.md
              echo "### All Releases" >> releases_section.md
              echo "" >> releases_section.md
              first_line=false
            fi
            
            # Add to releases list
            echo "- [$tag]($html_url) - $date" >> releases_section.md
          done
          
          # Clean up temp file
          rm -f releases_temp.txt
          
          # Update README.md
          # This replaces content between <!-- RELEASES_START --> and <!-- RELEASES_END -->
          # If markers don't exist, it appends to the end
          
          if grep -q "<!-- RELEASES_START -->" README.md; then
            # Markers exist, replace content between them
            awk '
              /<!-- RELEASES_START -->/ {print; system("cat releases_section.md"); f=1; next}
              /<!-- RELEASES_END -->/ {f=0}
              !f
            ' README.md > README.tmp
            mv README.tmp README.md
          else
            # Markers don't exist, append to end
            echo "" >> README.md
            echo "<!-- RELEASES_START -->" >> README.md
            cat releases_section.md >> README.md
            echo "<!-- RELEASES_END -->" >> README.md
          fi
          
          # Clean up
          rm releases_section.md
      
      - name: Commit changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add README.md
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update README with latest releases"
            git push
          fi
